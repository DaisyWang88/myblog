<!Doctype html>
<html>
<head>
<meta charset="utf-8">
<title>void 0==undefined,一般用void 0 获取undefined ，成为通用</title>
 
</head>
<body>

  <script>

	/*var object={
	 _name:"Daisy",
	  get name(){//这里的方法名name ,就表示定义了一个name属性（因此才能通过object.name访问），只定义了getter访问器，没有定义[[value]]值
	     return this._name;
	  }//get,set方法只是属性的特性 ，不是对象方法，决定属性能否、怎么读写
	  };
	alert(object.name);// Daisy这里去掉下划线 方法就是Daisy  ；加上就是undefined
	object.name="jack";//只定义了getter访问器，因此只能读不能写
	alert(object.name);//Daisy
	*/
	//以上方法等同于：
	var object={
	  _name:"Daisy" 
	};
	Object.defineProperty(object,"name",{//这里的方法名name,就表示定义了一个name属性（因此才能通过object.name访问）,只定义了getter访问器,没有定义[[value]]值
	   get:function (){//只定义了get 特性，因此只能读不能写
	      return this._name;
	   }
	
	});
	alert(object.name);//"Daisy"
	object.name="jack";//只定义了getter访问器，因此写入失效
	alert(object.name);//"Daisy"
	
	
	
	
	/*	var object={
	  _name:"Daisy" 
	};
	Object.defineProperty(object,"name",{//这里的方法名name,就表示定义了一个name属性（因此才能通过object.name访问）,只定义了getter访问器,没有定义[[value]]值
	   get:function (){//只定义了get 特性，因此只能读不能写
	      return this._name;
	   }
	
	});
	//能读不能写，但get 函数返回的是this._name ,因此读取不到name
	alert(object.name);//undefined
	object.name="jack";//只定义了getter访问器，因此只能读不能写
	alert(object.name);//undefined
	
	*/
 /*	var obj={
    	name:"john",
	   get:function (){
	      return this.age;
	   }//只定义了get ,没有定义set,但是仍然可以读，写，name属性，即使这里是age
	   //这里这样定义的方法不会影响属性的get,set 特性。只是普通的对象属性
	};

	alert(obj.name);//john 可读
	obj.name="jack";//可写
	alert(obj.name);//jack
	*/
  </script>

</body>
</html>
